// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/ai/go/pkg/mod/github.com/erigontech/mdbx-go@v0.27.14/mdbx/txn.go:1:1
package mdbx

/*
#include <stdlib.h>
#include <stdio.h>
#include "mdbxgo.h"
*/
import _ "unsafe"

import (
	"log"
	"time"
	"unsafe"
)

// This flags are used exclusively for Txn.OpenDBI and Txn.OpenRoot.  The
// Create flag must always be supplied when opening a non-root DBI for the
// first time.
//
// BUG(bmatsuo):
// MDBX_INTEGERKEY and MDBX_INTEGERDUP aren't usable. I'm not sure they would be
// faster with the cgo bridge.  They need to be tested and benchmarked.
const (
	// Flags for Txn.OpenDBI.

	ReverseKey = ( /*line :26:15*/_Ciconst_MDBX_REVERSEKEY /*line :26:31*/) // Use reverse string keys.
	DupSort    = ( /*line :27:15*/_Ciconst_MDBX_DUPSORT /*line :27:28*/)    // Use sorted duplicates.
	DupFixed   = ( /*line :28:15*/_Ciconst_MDBX_DUPFIXED /*line :28:29*/)   // Duplicate items have a fixed size (DupSort).
	ReverseDup = ( /*line :29:15*/_Ciconst_MDBX_REVERSEDUP /*line :29:31*/) // Reverse duplicate values (DupSort).
	Create     = ( /*line :30:15*/_Ciconst_MDBX_CREATE /*line :30:27*/)     // Create DB if not already existing.
	DBAccede   = ( /*line :31:15*/_Ciconst_MDBX_DB_ACCEDE /*line :31:30*/)  // Use sorted duplicates.
)

const (
	TxRW        = ( /*line :35:16*/_Ciconst_MDBX_TXN_READWRITE /*line :35:35*/)
	TxRO        = ( /*line :36:16*/_Ciconst_MDBX_TXN_RDONLY /*line :36:32*/)
	TxPrepareRO = ( /*line :37:16*/_Ciconst_MDBX_TXN_RDONLY_PREPARE /*line :37:40*/)

	TxTry        = ( /*line :39:17*/_Ciconst_MDBX_TXN_TRY /*line :39:30*/)
	TxNoMetaSync = ( /*line :40:17*/_Ciconst_MDBX_TXN_NOMETASYNC /*line :40:37*/)
	TxNoSync     = ( /*line :41:17*/_Ciconst_MDBX_TXN_NOSYNC /*line :41:33*/)
)

// Txn is a database transaction in an environment.
//
// WARNING: A writable Txn is not threadsafe and may only be used in the
// goroutine that created it.
//
// See MDBX_txn.
type Txn struct {
	env  *Env
	_txn * /*line :52:8*/_Ctype_MDBX_txn /*line :52:18*/
	key  * /*line :53:8*/_Ctype_MDBX_val /*line :53:18*/
	val  * /*line :54:8*/_Ctype_MDBX_val /*line :54:18*/

	errLogf func(format string, v ...interface{})

	// Pooled may be set to true while a Txn is stored in a sync.Pool, after
	// Txn.Reset reset has been called and before Txn.Renew.  This will keep
	// the Txn finalizer from unnecessarily warning the application about
	// finalizations.
	Pooled bool

	managed  bool
	readonly bool

	// The value of Txn.ID() is cached so that the cost of cgo does not have to
	// be paid.  The id of a Txn cannot change over its life, even if it is
	// reset/renewed
	id uint64
}

// beginTxn does not lock the OS thread which is a prerequisite for creating a
// write transaction.
func beginTxn(env *Env, parent *Txn, flags uint) (*Txn, error) {
	txn := &Txn{
		readonly: flags&Readonly != 0,
		env:      env,
	}

	var ptxn * /*line :81:12*/_Ctype_MDBX_txn /*line :81:22*/
	if parent == nil {
		if flags&Readonly == 0 {
			// In a write Txn we can use the shared, C-allocated key and value
			// allocated by env, and freed when it is closed.
			txn.key = env.ckey
			txn.val = env.cval
		} else {
			// It is not easy to share C.MDBX_val values in this scenario unless
			// there is a synchronized pool involved, which will increase
			// overhead.  Further, allocating these values with C will add
			// overhead both here and when the values are freed.
			txn.key = new( /*line :93:18*/_Ctype_MDBX_val /*line :93:28*/)
			txn.val = new( /*line :94:18*/_Ctype_MDBX_val /*line :94:28*/)
		}
	} else {
		// Because parent Txn objects cannot be used while a sub-Txn is active
		// it is OK for them to share their C.MDBX_val objects.
		ptxn = parent._txn
		txn.key = parent.key
		txn.val = parent.val
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :103:26*/env._env; _cgo1 := /*line :103:36*/ptxn; var _cgo2 _Ctype_MDBX_txn_flags_t = _Ctype_MDBX_txn_flags_t /*line :103:60*/(flags); _cgoBase3 := /*line :103:69*/&txn._txn; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :103:79*/_Cfunc_mdbx_txn_begin(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != success {
		return nil, operrno("mdbx_txn_begin", ret)
	}
	return txn, nil
}

// ID returns the identifier for txn.  A view transaction identifier
// corresponds to the Env snapshot being viewed and may be shared with other
// view transactions.
//
// See mdbx_txn_id.
func (txn *Txn) ID() uint64 {
	// It is possible for a txn to legitimately have ID 0 if it a readonly txn
	// created before any updates.  In practice this does not really happen
	// because an application typically must do an initial update to initialize
	// application dbis.  Even so, calling C.mdbx_txn_id excessively isn't
	// actually harmful, it is just slow.
	if txn.id == 0 {
		txn.id = txn.getID()
	}

	return txn.id
}

func (txn *Txn) getID() uint64 {
	return uint64(func() _Ctype_uint64_t{ _cgo0 := /*line :129:30*/txn._txn; _cgoCheckPointer(_cgo0, nil); return /*line :129:39*/_Cfunc_mdbx_txn_id(_cgo0); }())
}

// RunOp executes fn with txn as an argument.  During the execution of fn no
// goroutine may call the Commit, Abort, Reset, and Renew methods on txn.
// RunOp returns the result of fn without any further action.  RunOp will not
// abort txn if fn returns an error, unless terminate is true.  If terminate is
// true then RunOp will attempt to commit txn if fn is successful, otherwise
// RunOp will abort txn before returning any failure encountered.
//
// RunOp primarily exists to allow applications and other packages to provide
// variants of the managed transactions provided by lmdb (i.e. View, Update,
// etc).  For example, the lmdbpool package uses RunOp to provide an
// Txn-friendly sync.Pool and a function analogous to Env.View that uses
// transactions from that pool.
func (txn *Txn) RunOp(fn TxnOp, terminate bool) error {
	if terminate {
		return txn.runOpTerm(fn)
	}
	return txn.runOp(fn)
}

func (txn *Txn) runOpTerm(fn TxnOp) error {
	if txn.managed {
		panic("managed transaction cannot be terminated directly")
	}
	defer txn.abort()

	// There is no need to restore txn.managed after fn has executed because
	// the Txn will terminate one way or another using methods which don't
	// check txn.managed.
	txn.managed = true

	err := fn(txn)
	if err != nil {
		return err
	}
	_, err = txn.commit()
	return err
}

func (txn *Txn) runOp(fn TxnOp) error {
	if !txn.managed {
		// Restoring txn.managed must be done in a deferred call otherwise the
		// caller may not be able to abort the transaction if a runtime panic
		// occurs (attempting to do so would cause another panic).
		txn.managed = true
		defer func() {
			txn.managed = false
		}()
	}
	return fn(txn)
}

// Commit persists all transaction operations to the database and clears the
// finalizer on txn.  A Txn cannot be used again after Commit is called.
//
// See mdbx_txn_commit.
func (txn *Txn) Commit() (CommitLatency, error) {
	if txn.managed {
		panic("managed transaction cannot be committed directly")
	}

	return txn.commit()
}

type CommitLatency struct {
	Preparation time.Duration
	GC          time.Duration
	Audit       time.Duration
	Write       time.Duration
	Sync        time.Duration
	Ending      time.Duration
	Whole       time.Duration
}

func (txn *Txn) commit() (CommitLatency, error) {
	var _stat  /*line :206:12*/_Ctype_MDBX_commit_latency /*line :206:33*/
	ret := func() _Ctype_int{ _cgo0 := /*line :207:30*/txn._txn; var _cgo1 *_Ctype_struct_MDBX_commit_latency = /*line :207:40*/&_stat; _cgoCheckPointer(_cgo0, nil); return /*line :207:47*/_Cfunc_mdbx_txn_commit_ex(_cgo0, _cgo1); }()
	txn.clearTxn()
	s := CommitLatency{
		Preparation: toDuration(_stat.preparation),
		GC:          toDuration(_stat.gc),
		Audit:       toDuration(_stat.audit),
		Write:       toDuration(_stat.write),
		Sync:        toDuration(_stat.sync),
		Ending:      toDuration(_stat.ending),
		Whole:       toDuration(_stat.whole),
	}
	if ret != success {
		return s, operrno("mdbx_txn_commit_ex", ret)
	}
	return s, nil
}

// Abort discards pending writes in the transaction and clears the finalizer on
// txn.  A Txn cannot be used again after Abort is called.
//
// See mdbx_txn_abort.
func (txn *Txn) Abort() {
	if txn.managed {
		panic("managed transaction cannot be aborted directly")
	}

	txn.abort()
}

func (txn *Txn) abort() {
	if txn._txn == nil {
		return
	}

	// Get a read-lock on the environment so we can abort txn if needed.
	// txn.env **should** terminate all readers otherwise when it closes.
	txn.env.closeLock.RLock()
	if txn.env._env != nil {
		func() _Ctype_int{ _cgo0 := /*line :245:20*/txn._txn; _cgoCheckPointer(_cgo0, nil); return /*line :245:29*/_Cfunc_mdbx_txn_abort(_cgo0); }()
	}
	txn.env.closeLock.RUnlock()

	txn.clearTxn()
}

func (txn *Txn) clearTxn() {
	// Clear the C object to prevent any potential future use of the freed
	// pointer.
	txn._txn = nil

	// Clear txn.id because it no longer matches the value of txn._txn (and
	// future calls to txn.ID() should not see the stale id).  Instead of
	// returning the old ID future calls to txn.ID() will query LMDB to make
	// sure the value returned for an invalid Txn is more or less consistent
	// for people familiar with the C semantics.
	txn.resetID()
}

// resetID has to be called anytime the value of Txn.getID() may change
// otherwise the cached value may diverge from the actual value and the
// abstraction has failed.
func (txn *Txn) resetID() {
	txn.id = 0
}

// Reset aborts the transaction clears internal state so the transaction may be
// reused by calling Renew.  If txn is not going to be reused txn.Abort() must
// be called to release its slot in the lock table and free its memory.  Reset
// panics if txn is managed by Update, View, etc.
//
// See mdbx_txn_reset.
func (txn *Txn) Reset() {
	if txn.managed {
		panic("managed transaction cannot be reset directly")
	}

	txn.reset()
}

func (txn *Txn) reset() {
	func() _Ctype_int{ _cgo0 := /*line :287:19*/txn._txn; _cgoCheckPointer(_cgo0, nil); return /*line :287:28*/_Cfunc_mdbx_txn_reset(_cgo0); }()
}

// Renew reuses a transaction that was previously reset by calling txn.Reset().
// Renew panics if txn is managed by Update, View, etc.
//
// See mdbx_txn_renew.
func (txn *Txn) Renew() error {
	if txn.managed {
		panic("managed transaction cannot be renewed directly")
	}

	return txn.renew()
}

func (txn *Txn) renew() error {
	ret := func() _Ctype_int{ _cgo0 := /*line :303:26*/txn._txn; _cgoCheckPointer(_cgo0, nil); return /*line :303:35*/_Cfunc_mdbx_txn_renew(_cgo0); }()

	// mdbx_txn_renew causes txn._txn to pick up a new transaction ID.  It's
	// slightly confusing in the LMDB docs.  Txn ID corresponds to database
	// snapshot the reader is holding, which is good because renewed
	// transactions can see updates which happened since they were created (or
	// since they were last renewed).  It should follow that renewing a Txn
	// results in the freeing of stale pages the Txn has been holding, though
	// this has not been confirmed in any way by bmatsuo as of 2017-02-15.
	txn.resetID()

	return operrno("mdbx_txn_renew", ret)
}

// OpenDBI opens a named database in the environment.  An error is returned if
// name is empty.  The DBI returned by OpenDBI can be used in other
// transactions but not before Txn has terminated.
//
// OpenDBI can only be called after env.SetMaxDBs() has been called to set the
// maximum number of named databases.
//
// The C API uses null terminated strings for database names.  A consequence is
// that names cannot contain null bytes themselves. OpenDBI does not check for
// null bytes in the name argument.
//
// See mdbx_dbi_open.
func (txn *Txn) OpenDBI(name string, flags uint, cmp, dcmp CmpFunc) (DBI, error) {
	cname := ( /*line :330:11*/_Cfunc_CString /*line :330:19*/)(name)
	dbi, err := txn.openDBI(cname, flags, (* /*line :331:42*/_Ctype_MDBX_cmp_func /*line :331:57*/)(unsafe.Pointer(cmp)), (* /*line :331:83*/_Ctype_MDBX_cmp_func /*line :331:98*/)(unsafe.Pointer(dcmp)))
	func() { _cgo0 := /*line :332:9*/unsafe.Pointer(cname); _cgoCheckPointer(_cgo0, nil); /*line :332:31*/_Cfunc_free(_cgo0); }()
	return dbi, err
}

func (txn *Txn) OpenDBISimple(name string, flags uint) (DBI, error) {
	cname := ( /*line :337:11*/_Cfunc_CString /*line :337:19*/)(name)
	dbi, err := txn.openDBISimple(cname, flags)
	func() { _cgo0 := /*line :339:9*/unsafe.Pointer(cname); _cgoCheckPointer(_cgo0, nil); /*line :339:31*/_Cfunc_free(_cgo0); }()
	return dbi, err
}

// CreateDBI is a shorthand for OpenDBI that passed the flag lmdb.Create.
func (txn *Txn) CreateDBI(name string) (DBI, error) {
	return txn.OpenDBI(name, Create, nil, nil)
}

// Flags returns the database flags for handle dbi.
func (txn *Txn) Flags(dbi DBI) (uint, error) {
	var cflags  /*line :350:13*/_Ctype_uint /*line :350:19*/
	ret := func() _Ctype_int{ _cgo0 := /*line :351:26*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :351:46*/(dbi); var _cgo2 *_Ctype_uint = /*line :351:53*/&cflags; _cgoCheckPointer(_cgo0, nil); return /*line :351:61*/_Cfunc_mdbx_dbi_flags(_cgo0, _cgo1, _cgo2); }()
	return uint(cflags), operrno("mdbx_dbi_flags", ret)
}

// OpenRoot opens the root database.  OpenRoot behaves similarly to OpenDBI but
// does not require env.SetMaxDBs() to be called beforehand.  And, OpenRoot can
// be called without flags in a View transaction.
func (txn *Txn) OpenRoot(flags uint) (DBI, error) {
	return txn.openDBI(nil, flags, nil, nil)
}

type Cmp func(k1, k2 []byte) int

// openDBI returns returns whatever DBI value was set by mdbx_open_dbi.  In an
// error case, LMDB does not currently set DBI in case of failure, so zero is
// returned in those cases.  This is not a big deal for now because
// applications are expected to handle any error encountered opening a
// database.
func (txn *Txn) openDBI(cname * /*line :369:32*/_Ctype_char /*line :369:38*/, flags uint, cmp, dcmp * /*line :369:63*/_Ctype_MDBX_cmp_func /*line :369:78*/) (DBI, error) {
	var dbi  /*line :370:10*/_Ctype_MDBX_dbi /*line :370:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :371:28*/txn._txn; var _cgo1 *_Ctype_char = /*line :371:38*/cname; var _cgo2 _Ctype_MDBX_db_flags_t = _Ctype_MDBX_db_flags_t /*line :371:62*/(flags); var _cgo3 *_Ctype_MDBX_dbi = /*line :371:71*/&dbi; var _cgo4 *_Ctype_MDBX_cmp_func = /*line :371:77*/cmp; var _cgo5 *_Ctype_MDBX_cmp_func = /*line :371:82*/dcmp; _cgoCheckPointer(_cgo0, nil); return /*line :371:87*/_Cfunc_mdbx_dbi_open_ex(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return DBI(dbi), operrno("mdbx_dbi_open", ret)
}

func (txn *Txn) openDBISimple(cname * /*line :375:38*/_Ctype_char /*line :375:44*/, flags uint) (DBI, error) {
	var dbi  /*line :376:10*/_Ctype_MDBX_dbi /*line :376:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :377:25*/txn._txn; var _cgo1 *_Ctype_char = /*line :377:35*/cname; var _cgo2 _Ctype_MDBX_db_flags_t = _Ctype_MDBX_db_flags_t /*line :377:59*/(flags); var _cgo3 *_Ctype_MDBX_dbi = /*line :377:68*/&dbi; _cgoCheckPointer(_cgo0, nil); return /*line :377:73*/_Cfunc_mdbx_dbi_open(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return DBI(dbi), operrno("mdbx_dbi_open", ret)
}

type TxInfo struct {
	Id uint64 // The ID of the transaction. For a READ-ONLY transaction, this corresponds to the snapshot being read
	/** For READ-ONLY transaction: the lag from a recent MVCC-snapshot, i.e. the
	  number of committed transaction since read transaction started. For WRITE
	  transaction (provided if `scan_rlt=true`): the lag of the oldest reader
	  from current transaction (i.e. at least 1 if any reader running). */
	ReadLag uint64
	/** Used space by this transaction, i.e. corresponding to the last used
	 * database page. */
	SpaceUsed uint64
	/** Current size of database file. */
	SpaceLimitSoft uint64
	/** Upper bound for size the database file, i.e. the value `size_upper`
	  argument of the appropriate call of \ref mdbx_env_set_geometry(). */
	SpaceLimitHard uint64
	/** For READ-ONLY transaction: The total size of the database pages that were
	  retired by committed write transactions after the reader's MVCC-snapshot,
	  i.e. the space which would be freed after the Reader releases the
	  MVCC-snapshot for reuse by completion read transaction.
	  For WRITE transaction: The summarized size of the database pages that were
	  retired for now due Copy-On-Write during this transaction. */
	SpaceRetired uint64
	/** For READ-ONLY transaction: the space available for writer(s) and that
	  must be exhausted for reason to call the Handle-Slow-Readers callback for
	  this read transaction. For WRITE transaction: the space inside transaction
	  that left to `MDBX_TXN_FULL` error. */
	SpaceLeftover uint64
	/** For READ-ONLY transaction (provided if `scan_rlt=true`): The space that
	  actually become available for reuse when only this transaction will be
	  finished.
	  For WRITE transaction: The summarized size of the dirty database
	  pages that generated during this transaction. */
	SpaceDirty uint64

	Spill   uint64
	Unspill uint64
}

// scan_rlt   The boolean flag controls the scan of the read lock
//
//	table to provide complete information. Such scan
//	is relatively expensive and you can avoid it
//	if corresponding fields are not needed.
//	See description of \ref MDBX_txn_info.
func (txn *Txn) Info(scanRlt bool) (*TxInfo, error) {
	var _stat  /*line :426:12*/_Ctype_MDBX_txn_info /*line :426:27*/
	ret := func() _Ctype_int{ _cgo0 := /*line :427:25*/txn._txn; var _cgo1 *_Ctype_struct_MDBX_txn_info = /*line :427:35*/&_stat; var _cgo2 _Ctype__Bool = _Ctype_bool /*line :427:49*/(scanRlt); _cgoCheckPointer(_cgo0, nil); return /*line :427:59*/_Cfunc_mdbx_txn_info(_cgo0, _cgo1, _cgo2); }()
	if ret != success {
		return nil, operrno("mdbx_txn_info", ret)
	}
	return &TxInfo{
		Id:             uint64(_stat.txn_id),
		ReadLag:        uint64(_stat.txn_reader_lag),
		SpaceUsed:      uint64(_stat.txn_space_used),
		SpaceLimitSoft: uint64(_stat.txn_space_limit_soft),
		SpaceLimitHard: uint64(_stat.txn_space_limit_hard),
		SpaceRetired:   uint64(_stat.txn_space_retired),
		SpaceLeftover:  uint64(_stat.txn_space_leftover),
		SpaceDirty:     uint64(_stat.txn_space_dirty),
	}, nil
}

func (txn *Txn) StatDBI(dbi DBI) (*Stat, error) {
	var _stat  /*line :444:12*/_Ctype_MDBX_stat /*line :444:23*/
	ret := func() _Ctype_int{ _cgo0 := /*line :445:25*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :445:45*/(dbi); var _cgo2 *_Ctype_struct_MDBX_stat = /*line :445:52*/&_stat; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :445:68*/(unsafe.Sizeof(_stat)); _cgoCheckPointer(_cgo0, nil); return /*line :445:91*/_Cfunc_mdbx_dbi_stat(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != success {
		return nil, operrno("mdbx_dbi_stat", ret)
	}
	stat := Stat{PSize: uint(_stat.ms_psize),
		Depth:         uint(_stat.ms_depth),
		BranchPages:   uint64(_stat.ms_branch_pages),
		LeafPages:     uint64(_stat.ms_leaf_pages),
		OverflowPages: uint64(_stat.ms_overflow_pages),
		Entries:       uint64(_stat.ms_entries)}
	return &stat, nil
}

// Drop empties the database if del is false.  Drop deletes and closes the
// database if del is true.
//
// See mdbx_drop.
func (txn *Txn) Drop(dbi DBI, del bool) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :463:21*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :463:41*/(dbi); var _cgo2 _Ctype__Bool = _Ctype_bool /*line :463:54*/(del); _cgoCheckPointer(_cgo0, nil); return /*line :463:60*/_Cfunc_mdbx_drop(_cgo0, _cgo1, _cgo2); }()
	return operrno("mdbx_drop", ret)
}

// Sub executes fn in a subtransaction.  Sub commits the subtransaction iff a
// nil error is returned by fn and otherwise aborts it.  Sub returns any error
// it encounters.
//
// Sub may only be called on an Update Txn (one created without the Readonly
// flag).  Calling Sub on a View transaction will return an error.  Sub assumes
// the calling goroutine is locked to an OS thread and will not call
// runtime.LockOSThread.
//
// Any call to Abort, Commit, Renew, or Reset on a Txn created by Sub will
// panic.
func (txn *Txn) Sub(fn TxnOp) error {
	// As of 0.9.14 Readonly is the only Txn flag and readonly subtransactions
	// don't make sense.
	return txn.subFlag(0, fn)
}

func (txn *Txn) subFlag(flags uint, fn TxnOp) error {
	sub, err := beginTxn(txn.env, txn, flags)
	if err != nil {
		return err
	}
	sub.managed = true
	defer sub.abort()
	err = fn(sub)
	if err != nil {
		return err
	}
	_, err = sub.commit()
	return err
}

func (txn *Txn) bytes(val * /*line :499:28*/_Ctype_MDBX_val /*line :499:38*/) []byte {
	return castToBytes(val)
}

// Get retrieves items from database dbi.  If txn.RawRead is true the slice
// returned by Get references a readonly section of memory that must not be
// accessed after txn has terminated.
//
// See mdbx_get.
func (txn *Txn) Get(dbi DBI, key []byte) ([]byte, error) {
	var k * /*line :509:9*/_Ctype_char /*line :509:15*/
	if len(key) > 0 {
		k = (* /*line :511:9*/_Ctype_char /*line :511:15*/)(unsafe.Pointer(&key[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :514:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :514:23*/(dbi); var _cgo2 *_Ctype_char = /*line :515:3*/k; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :515:14*/(len(key)); _cgo4 := /*line :516:3*/txn.val; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo4, nil); return /*line :517:3*/_Cfunc_mdbxgo_get(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	err := operrno("mdbx_get", ret)
	if err != nil {
		*txn.val =  /*line :520:14*/_Ctype_MDBX_val /*line :520:24*/{}
		return nil, err
	}
	b := castToBytes(txn.val)
	*txn.val =  /*line :524:13*/_Ctype_MDBX_val /*line :524:23*/{}
	return b, nil
}

// Put stores an item in database dbi.
//
// See mdbx_put.
func (txn *Txn) Put(dbi DBI, key, val []byte, flags uint) error {
	var k, v * /*line :532:12*/_Ctype_char /*line :532:18*/
	if len(key) > 0 {
		k = (* /*line :534:9*/_Ctype_char /*line :534:15*/)(unsafe.Pointer(&key[0]))
	}
	if len(val) > 0 {
		v = (* /*line :537:9*/_Ctype_char /*line :537:15*/)(unsafe.Pointer(&val[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :540:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :540:23*/(dbi); var _cgo2 *_Ctype_char = /*line :541:3*/k; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :541:14*/(len(key)); var _cgo4 *_Ctype_char = /*line :542:3*/v; var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :542:14*/(len(val)); var _cgo6 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :543:21*/(flags); _cgoCheckPointer(_cgo0, nil); return /*line :544:3*/_Cfunc_mdbxgo_put2(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	return operrno("mdbx_put", ret)
}

// PutReserve returns a []byte of length n that can be written to, potentially
// avoiding a memcopy.  The returned byte slice is only valid in txn's thread,
// before it has terminated.
func (txn *Txn) PutReserve(dbi DBI, key []byte, n int, flags uint) ([]byte, error) {
	txn.val.iov_len =  /*line :552:20*/_Ctype_size_t /*line :552:28*/(n)
	var k * /*line :553:9*/_Ctype_char /*line :553:15*/
	if len(key) > 0 {
		k = (* /*line :555:9*/_Ctype_char /*line :555:15*/)(unsafe.Pointer(&key[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :558:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :558:23*/(dbi); var _cgo2 *_Ctype_char = /*line :559:3*/k; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :559:14*/(len(key)); _cgo4 := /*line :560:3*/txn.val; var _cgo5 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :561:21*/(flags | _Ciconst_MDBX_RESERVE /*line :561:42*/); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo4, nil); return /*line :562:3*/_Cfunc_mdbxgo_put1(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	err := operrno("mdbx_put", ret)
	if err != nil {
		*txn.val =  /*line :565:14*/_Ctype_MDBX_val /*line :565:24*/{}
		return nil, err
	}
	b := castToBytes(txn.val)
	*txn.val =  /*line :569:13*/_Ctype_MDBX_val /*line :569:23*/{}
	return b, nil
}

// Del deletes an item from database dbi.  Del ignores val unless dbi has the
// DupSort flag.
//
// See mdbx_del.
func (txn *Txn) Del(dbi DBI, key, val []byte) error {
	var k, v * /*line :578:12*/_Ctype_char /*line :578:18*/
	if len(key) > 0 {
		k = (* /*line :580:9*/_Ctype_char /*line :580:15*/)(unsafe.Pointer(&key[0]))
	}
	if len(val) > 0 {
		v = (* /*line :583:9*/_Ctype_char /*line :583:15*/)(unsafe.Pointer(&val[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :586:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :586:23*/(dbi); var _cgo2 *_Ctype_char = /*line :587:3*/k; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :587:14*/(len(key)); var _cgo4 *_Ctype_char = /*line :588:3*/v; var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :588:14*/(len(val)); _cgoCheckPointer(_cgo0, nil); return /*line :589:3*/_Cfunc_mdbxgo_del(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return operrno("mdbx_del", ret)
}

// OpenCursor allocates and initializes a Cursor to database dbi.
//
// See mdbx_cursor_open.
func (txn *Txn) OpenCursor(dbi DBI) (*Cursor, error) {
	return openCursor(txn, dbi)
}

func (txn *Txn) errf(format string, v ...interface{}) {
	if txn.errLogf != nil {
		txn.errLogf(format, v...)
		return
	}
	log.Printf(format, v...)
}

// TxnOp is an operation applied to a managed transaction.  The Txn passed to a
// TxnOp is managed and the operation must not call Commit, Abort, Renew, or
// Reset on it.
//
// IMPORTANT:
// TxnOps that write to the database (those passed to Env.Update or Txn.Sub)
// must not use the Txn in another goroutine (passing it directly or otherwise
// through closure).  Doing so has undefined results.
type TxnOp func(txn *Txn) error

type CmpFunc * /*line :618:15*/_Ctype_MDBX_cmp_func /*line :618:30*/

// Cmp - this func follow bytes.Compare return style: The result will be 0 if a==b, -1 if a < b, and +1 if a > b.
func (txn *Txn) Cmp(dbi DBI, a []byte, b []byte) int {
	var adata, bdata * /*line :622:20*/_Ctype_char /*line :622:26*/
	if len(a) > 0 {
		adata = (* /*line :624:13*/_Ctype_char /*line :624:19*/)(unsafe.Pointer(&a[0]))
	}
	if len(b) > 0 {
		bdata = (* /*line :627:13*/_Ctype_char /*line :627:19*/)(unsafe.Pointer(&b[0]))
	}
	ret := int(func() _Ctype_int{ _cgo0 := /*line :630:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :630:23*/(dbi); var _cgo2 *_Ctype_char = /*line :631:3*/adata; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :631:18*/(len(a)); var _cgo4 *_Ctype_char = /*line :632:3*/bdata; var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :632:18*/(len(b)); _cgoCheckPointer(_cgo0, nil); return /*line :633:3*/_Cfunc_mdbxgo_cmp(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }())
	if ret > 0 {
		return 1
	}
	if ret < 0 {
		return -1
	}
	return 0
}

// DCmp - this func follow bytes.Compare return style: The result will be 0 if a==b, -1 if a < b, and +1 if a > b.
func (txn *Txn) DCmp(dbi DBI, a []byte, b []byte) int {
	var adata, bdata * /*line :645:20*/_Ctype_char /*line :645:26*/
	if len(a) > 0 {
		adata = (* /*line :647:13*/_Ctype_char /*line :647:19*/)(unsafe.Pointer(&a[0]))
	}
	if len(b) > 0 {
		bdata = (* /*line :650:13*/_Ctype_char /*line :650:19*/)(unsafe.Pointer(&b[0]))
	}
	ret := int(func() _Ctype_int{ _cgo0 := /*line :653:3*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :653:23*/(dbi); var _cgo2 *_Ctype_char = /*line :654:3*/adata; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :654:18*/(len(a)); var _cgo4 *_Ctype_char = /*line :655:3*/bdata; var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :655:18*/(len(b)); _cgoCheckPointer(_cgo0, nil); return /*line :656:3*/_Cfunc_mdbxgo_dcmp(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }())
	if ret > 0 {
		return 1
	}
	if ret < 0 {
		return -1
	}
	return 0
}

func (txn *Txn) Sequence(dbi DBI, increment uint64) (uint64, error) {
	var res  /*line :667:10*/_Ctype_uint64_t /*line :667:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :668:29*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :668:49*/(dbi); var _cgo2 *_Ctype_uint64_t = /*line :668:56*/&res; var _cgo3 _Ctype_uint64_t = _Ctype_uint64_t /*line :668:72*/(increment); _cgoCheckPointer(_cgo0, nil); return /*line :668:84*/_Cfunc_mdbx_dbi_sequence(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != 0 {
		return uint64(res), operrno("mdbx_dbi_sequence", ret)
	}
	return uint64(res), nil
}

// ListDBI - return all dbi names. they stored as keys of un-named (main) dbi
func (txn *Txn) ListDBI() (res []string, err error) {
	root, err := txn.OpenRoot(0)
	if err != nil {
		return nil, err
	}
	c, err := txn.OpenCursor(root)
	if err != nil {
		return nil, err
	}
	for k, _, err := c.Get(nil, nil, First); k != nil; k, _, err = c.Get(nil, nil, Next) {
		if err != nil {
			return nil, err
		}
		res = append(res, string(k))
	}
	return res, nil
}
