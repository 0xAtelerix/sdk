// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/ai/go/pkg/mod/github.com/erigontech/mdbx-go@v0.27.14/mdbx/env.go:1:1
package mdbx

/*
#include <stdlib.h>
#include <stdio.h>
#include "mdbxgo.h"
*/
import _ "unsafe"
import (
	"errors"
	"os"
	"runtime"
	"sync"
	"time"
	"unsafe"
)

// success is a value returned from the MDBX API to indicate a successful call.
// The functions in this API this behavior and its use is not required.
const success = ( /*line :20:17*/_Ciconst_MDBX_SUCCESS /*line :20:30*/)

const Major = ( /*line :22:15*/_Ciconst_MDBX_VERSION_MAJOR /*line :22:34*/)
const Minor = ( /*line :23:15*/_Ciconst_MDBX_VERSION_MINOR /*line :23:34*/)

const (
	// Flags for Env.Open.
	//
	// See mdbx_env_open

	EnvDefaults = ( /*line :30:16*/_Ciconst_MDBX_ENV_DEFAULTS /*line :30:34*/)
	LifoReclaim = ( /*line :31:16*/_Ciconst_MDBX_LIFORECLAIM /*line :31:33*/)
	//FixedMap    = C.MDBX_FIXEDMAP   // Danger zone. Map memory at a fixed address.
	NoSubdir      = ( /*line :33:18*/_Ciconst_MDBX_NOSUBDIR /*line :33:32*/) // Argument to Open is a file, not a directory.
	Accede        = ( /*line :34:18*/_Ciconst_MDBX_ACCEDE /*line :34:30*/)
	Coalesce      = ( /*line :35:18*/_Ciconst_MDBX_COALESCE /*line :35:32*/)
	Readonly      = ( /*line :36:18*/_Ciconst_MDBX_RDONLY /*line :36:30*/)     // Used in several functions to denote an object as readonly.
	WriteMap      = ( /*line :37:18*/_Ciconst_MDBX_WRITEMAP /*line :37:32*/)   // Use a writable memory map.
	NoMetaSync    = ( /*line :38:18*/_Ciconst_MDBX_NOMETASYNC /*line :38:34*/) // Don't fsync metapage after commit.
	UtterlyNoSync = ( /*line :39:18*/_Ciconst_MDBX_UTTERLY_NOSYNC /*line :39:38*/)
	SafeNoSync    = ( /*line :40:18*/_Ciconst_MDBX_SAFE_NOSYNC /*line :40:35*/)
	Durable       = ( /*line :41:18*/_Ciconst_MDBX_SYNC_DURABLE /*line :41:36*/)
	NoTLS         = ( /*line :42:18*/_Ciconst_MDBX_NOTLS /*line :42:29*/) // Danger zone. When unset reader locktable slots are tied to their thread.
	//NoLock      = C.MDBX_NOLOCK     // Danger zone. MDBX does not use any locks.
	NoReadahead = ( /*line :44:16*/_Ciconst_MDBX_NORDAHEAD /*line :44:31*/) // Disable readahead. Requires OS support.
	NoMemInit   = ( /*line :45:16*/_Ciconst_MDBX_NOMEMINIT /*line :45:31*/) // Disable MDBX memory initialization.
	Exclusive   = ( /*line :46:16*/_Ciconst_MDBX_EXCLUSIVE /*line :46:31*/) // Disable MDBX memory initialization.
)

const (
	MinPageSize = ( /*line :50:16*/_Ciconst_MDBX_MIN_PAGESIZE /*line :50:34*/)
	MaxPageSize = ( /*line :51:16*/_Ciconst_MDBX_MAX_PAGESIZE /*line :51:34*/)
	MaxDbi      = ( /*line :52:16*/_Ciconst_MDBX_MAX_DBI /*line :52:29*/)
)

// These flags are exclusively used in the Env.CopyFlags and Env.CopyFDFlags
// methods.
const (
	// Flags for Env.CopyFlags
	//
	// See mdbx_env_copy2

	CopyCompact = ( /*line :62:16*/_Ciconst_MDBX_CP_COMPACT /*line :62:32*/) // Perform compaction while copying
)

const (
	AllowTxOverlap = ( /*line :66:19*/_Ciconst_MDBX_DBG_LEGACY_OVERLAP /*line :66:43*/)
)

type LogLvl =  /*line :69:15*/_Ctype_MDBX_log_level_t /*line :69:33*/

const (
	LogLvlFatal       = ( /*line :72:22*/_Ciconst_MDBX_LOG_FATAL /*line :72:37*/)
	LogLvlError       = ( /*line :73:22*/_Ciconst_MDBX_LOG_ERROR /*line :73:37*/)
	LogLvlWarn        = ( /*line :74:22*/_Ciconst_MDBX_LOG_WARN /*line :74:36*/)
	LogLvlNotice      = ( /*line :75:22*/_Ciconst_MDBX_LOG_NOTICE /*line :75:38*/)
	LogLvlVerbose     = ( /*line :76:22*/_Ciconst_MDBX_LOG_VERBOSE /*line :76:39*/)
	LogLvlDebug       = ( /*line :77:22*/_Ciconst_MDBX_LOG_DEBUG /*line :77:37*/)
	LogLvlTrace       = ( /*line :78:22*/_Ciconst_MDBX_LOG_TRACE /*line :78:37*/)
	LogLvlExtra       = ( /*line :79:22*/_Ciconst_MDBX_LOG_EXTRA /*line :79:37*/)
	LogLvlDoNotChange = ( /*line :80:22*/_Ciconst_MDBX_LOG_DONTCHANGE /*line :80:42*/)
)

const (
	DbgAssert          = ( /*line :84:23*/_Ciconst_MDBX_DBG_ASSERT /*line :84:39*/)
	DbgAudit           = ( /*line :85:23*/_Ciconst_MDBX_DBG_AUDIT /*line :85:38*/)
	DbgJitter          = ( /*line :86:23*/_Ciconst_MDBX_DBG_JITTER /*line :86:39*/)
	DbgDump            = ( /*line :87:23*/_Ciconst_MDBX_DBG_DUMP /*line :87:37*/)
	DbgLegacyMultiOpen = ( /*line :88:23*/_Ciconst_MDBX_DBG_LEGACY_MULTIOPEN /*line :88:49*/)
	DbgLegacyTxOverlap = ( /*line :89:23*/_Ciconst_MDBX_DBG_LEGACY_OVERLAP /*line :89:47*/)
	DbgDoNotChange     = ( /*line :90:23*/_Ciconst_MDBX_DBG_DONTCHANGE /*line :90:43*/)
)

const (
	OptMaxDB                        = ( /*line :94:36*/_Ciconst_MDBX_opt_max_db /*line :94:52*/)
	OptMaxReaders                   = ( /*line :95:36*/_Ciconst_MDBX_opt_max_readers /*line :95:57*/)
	OptSyncBytes                    = ( /*line :96:36*/_Ciconst_MDBX_opt_sync_bytes /*line :96:56*/)
	OptSyncPeriod                   = ( /*line :97:36*/_Ciconst_MDBX_opt_sync_period /*line :97:57*/)
	OptRpAugmentLimit               = ( /*line :98:36*/_Ciconst_MDBX_opt_rp_augment_limit /*line :98:62*/)
	OptLooseLimit                   = ( /*line :99:36*/_Ciconst_MDBX_opt_loose_limit /*line :99:57*/)
	OptDpReverseLimit               = ( /*line :100:36*/_Ciconst_MDBX_opt_dp_reserve_limit /*line :100:62*/)
	OptTxnDpLimit                   = ( /*line :101:36*/_Ciconst_MDBX_opt_txn_dp_limit /*line :101:58*/)
	OptTxnDpInitial                 = ( /*line :102:36*/_Ciconst_MDBX_opt_txn_dp_initial /*line :102:60*/)
	OptSpillMaxDenominator          = ( /*line :103:36*/_Ciconst_MDBX_opt_spill_max_denominator /*line :103:67*/)
	OptSpillMinDenominator          = ( /*line :104:36*/_Ciconst_MDBX_opt_spill_min_denominator /*line :104:67*/)
	OptSpillParent4ChildDenominator = ( /*line :105:36*/_Ciconst_MDBX_opt_spill_parent4child_denominator /*line :105:76*/)
	OptMergeThreshold16dot16Percent = ( /*line :106:36*/_Ciconst_MDBX_opt_merge_threshold_16dot16_percent /*line :106:77*/)
)

var (
	LoggerDoNotChange = ( /*line :110:22*/_Cmacro_MDBX_LOGGER_DONTCHANGE() /*line :110:45*/)
)

// DBI is a handle for a database in an Env.
//
// See MDBX_dbi
type DBI  /*line :116:10*/_Ctype_MDBX_dbi /*line :116:20*/

// Env is opaque structure for a database environment.  A DB environment
// supports multiple databases, all residing in the same shared-memory map.
//
// See MDBX_env.
type Env struct {
	_env * /*line :123:8*/_Ctype_MDBX_env /*line :123:18*/
	ckey * /*line :124:8*/_Ctype_MDBX_val /*line :124:18*/
	cval * /*line :125:8*/_Ctype_MDBX_val /*line :125:18*/

	// closeLock is used to allow the Txn finalizer to check if the Env has
	// been closed, so that it may know if it must abort.
	closeLock sync.RWMutex
}

// NewEnv allocates and initializes a new Env.
//
// See mdbx_env_create.
func NewEnv() (*Env, error) {
	env := new(Env)
	ret := func() _Ctype_int{ _cgoBase0 := /*line :137:27*/&env._env; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :137:37*/_Cfunc_mdbx_env_create(_cgo0); }()
	if ret != success {
		return nil, operrno("mdbx_env_create", ret)
	}
	env.ckey = (* /*line :141:15*/_Ctype_MDBX_val /*line :141:25*/)(( /*line :141:27*/_Cfunc__CMalloc /*line :141:34*/)( /*line :141:36*/_Ctype_size_t /*line :141:44*/(unsafe.Sizeof( /*line :141:59*/_Ctype_MDBX_val /*line :141:69*/{}))))
	env.cval = (* /*line :142:15*/_Ctype_MDBX_val /*line :142:25*/)(( /*line :142:27*/_Cfunc__CMalloc /*line :142:34*/)( /*line :142:36*/_Ctype_size_t /*line :142:44*/(unsafe.Sizeof( /*line :142:59*/_Ctype_MDBX_val /*line :142:69*/{}))))
	return env, nil
}

// Open an environment handle. If this function fails Close() must be called to
// discard the Env handle.  Open passes flags|NoTLS to mdbx_env_open.
//
// See mdbx_env_open.
func (env *Env) Open(path string, flags uint, mode os.FileMode) error {
	cpath := ( /*line :151:11*/_Cfunc_CString /*line :151:19*/)(path)
	defer func() func() { _cgo0 := /*line :152:15*/unsafe.Pointer(cpath); return func() { _cgoCheckPointer(_cgo0, nil); /*line :152:37*/_Cfunc_free(_cgo0); }}()()
	ret := func() _Ctype_int{ _cgo0 := /*line :153:25*/env._env; var _cgo1 *_Ctype_char = /*line :153:35*/cpath; var _cgo2 _Ctype_MDBX_env_flags_t = _Ctype_MDBX_env_flags_t /*line :153:60*/(NoTLS | flags); var _cgo3 _Ctype_mdbx_mode_t = _Ctype_mdbx_mode_t /*line :153:88*/(mode); _cgoCheckPointer(_cgo0, nil); return /*line :153:95*/_Cfunc_mdbx_env_open(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return operrno("mdbx_env_open", ret)
}

var errNotOpen = errors.New("enivornment is not open")

/* TODO: fix error: cannot convert *mf (variable of type _Ctype_HANDLE) to type uintptr

// FD returns the open file descriptor (or Windows file handle) for the given
// environment.  An error is returned if the environment has not been
// successfully Opened (where C API just retruns an invalid handle).
//
// See mdbx_env_get_fd.
func (env *Env) FD() (uintptr, error) {
	// fdInvalid is the value -1 as a uintptr, which is used by MDBX in the
	// case that env has not been opened yet.  the strange construction is done
	// to avoid constant value overflow errors at compile time.
	const fdInvalid = ^uintptr(0)

	mf := new(C.mdbx_filehandle_t)
	ret := C.mdbx_env_get_fd(env._env, mf)
	err := operrno("mdbx_env_get_fd", ret)
	if err != nil {
		return 0, err
	}
	fd := uintptr(*mf)

	if fd == fdInvalid {
		return 0, errNotOpen
	}
	return fd, nil
}
*/

// ReaderList dumps the contents of the reader lock table as text.  Readers
// start on the second line as space-delimited fields described by the first
// line.
//
// See mdbx_reader_list.
//func (env *Env) ReaderList(fn func(string) error) error {
//	ctx, done := newMsgFunc(fn)
//	defer done()
//	if fn == nil {
//		ctx = 0
//	}
//
//	ret := C.mdbxgo_reader_list(env._env, C.size_t(ctx))
//	if ret >= 0 {
//		return nil
//	}
//	if ret < 0 && ctx != 0 {
//		err := ctx.get().err
//		if err != nil {
//			return err
//		}
//	}
//	return operrno("mdbx_reader_list", ret)
//}

// ReaderCheck clears stale entries from the reader lock table and returns the
// number of entries cleared.
//
// See mdbx_reader_check()
func (env *Env) ReaderCheck() (int, error) {
	var _dead  /*line :217:12*/_Ctype_int /*line :217:17*/
	ret := func() _Ctype_int{ _cgo0 := /*line :218:29*/env._env; var _cgo1 *_Ctype_int = /*line :218:39*/&_dead; _cgoCheckPointer(_cgo0, nil); return /*line :218:46*/_Cfunc_mdbx_reader_check(_cgo0, _cgo1); }()
	return int(_dead), operrno("mdbx_reader_check", ret)
}

// Close shuts down the environment, releases the memory map, and clears the
// finalizer on env.
//
// See mdbx_env_close.
func (env *Env) Close() {
	if env._env == nil {
		return
	}

	env.closeLock.Lock()
	func() _Ctype_int{ _cgo0 := /*line :232:19*/env._env; _cgoCheckPointer(_cgo0, nil); return /*line :232:28*/_Cfunc_mdbx_env_close(_cgo0); }()
	env._env = nil
	env.closeLock.Unlock()

	func() { _cgo0 := /*line :236:9*/unsafe.Pointer(env.ckey); _cgoCheckPointer(_cgo0, nil); /*line :236:34*/_Cfunc_free(_cgo0); }()
	func() { _cgo0 := /*line :237:9*/unsafe.Pointer(env.cval); _cgoCheckPointer(_cgo0, nil); /*line :237:34*/_Cfunc_free(_cgo0); }()
	env.ckey = nil
	env.cval = nil
}

// CopyFD copies env to the the file descriptor fd.
//
// See mdbx_env_copyfd.
//func (env *Env) CopyFD(fd uintptr) error {
//	ret := C.mdbx_env_copyfd(env._env, C.mdbx_filehandle_t(fd))
//	return operrno("mdbx_env_copyfd", ret)
//}

// CopyFDFlag copies env to the file descriptor fd, with options.
//
// See mdbx_env_copyfd2.
//func (env *Env) CopyFDFlag(fd uintptr, flags uint) error {
//	ret := C.mdbx_env_copyfd2(env._env, C.mdbx_filehandle_t(fd), C.uint(flags))
//	return operrno("mdbx_env_copyfd2", ret)
//}

// Copy copies the data in env to an environment at path.
//
// See mdbx_env_copy.
//func (env *Env) Copy(path string) error {
//	cpath := C.CString(path)
//	defer C.free(unsafe.Pointer(cpath))
//	ret := C.mdbx_env_copy(env._env, cpath)
//	return operrno("mdbx_env_copy", ret)
//}

// CopyFlag copies the data in env to an environment at path created with flags.
//
// See mdbx_env_copy2.
//func (env *Env) CopyFlag(path string, flags uint) error {
//	cpath := C.CString(path)
//	defer C.free(unsafe.Pointer(cpath))
//	ret := C.mdbx_env_copy2(env._env, cpath, C.uint(flags))
//	return operrno("mdbx_env_copy2", ret)
//}

// Stat contains database status information.
//
// See MDBX_stat.
type Stat struct {
	PSize         uint   // Size of a database page. This is currently the same for all databases.
	Depth         uint   // Depth (height) of the B-tree
	BranchPages   uint64 // Number of internal (non-leaf) pages
	LeafPages     uint64 // Number of leaf pages
	OverflowPages uint64 // Number of overflow pages
	Entries       uint64 // Number of data items
	LastTxId      uint64 // Transaction ID of commited last modification
}

// Stat returns statistics about the environment.
//
// See mdbx_env_stat.
func (env *Env) Stat() (*Stat, error) {
	var _stat  /*line :295:12*/_Ctype_MDBX_stat /*line :295:23*/
	var ret  /*line :296:10*/_Ctype_int /*line :296:15*/ = func() _Ctype_int{ _cgo0 := /*line :296:37*/env._env; var _cgo1 *_Ctype_struct_MDBX_txn = /*line :296:47*/nil; var _cgo2 *_Ctype_struct_MDBX_stat = /*line :296:52*/&_stat; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :296:68*/(unsafe.Sizeof(_stat)); _cgoCheckPointer(_cgo0, nil); return /*line :296:91*/_Cfunc_mdbx_env_stat_ex(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != success {
		return nil, operrno("mdbx_env_stat_ex", ret)
	}
	stat := Stat{PSize: uint(_stat.ms_psize),
		Depth:         uint(_stat.ms_depth),
		BranchPages:   uint64(_stat.ms_branch_pages),
		LeafPages:     uint64(_stat.ms_leaf_pages),
		OverflowPages: uint64(_stat.ms_overflow_pages),
		Entries:       uint64(_stat.ms_entries),
		LastTxId:      uint64(_stat.ms_mod_txnid)}
	return &stat, nil
}

type EnvInfoGeo struct {
	Lower   uint64
	Upper   uint64
	Current uint64
	Shrink  uint64
	Grow    uint64
}
type EnfInfoPageOps struct {
	Newly   uint64        /**< Quantity of a new pages added */
	Cow     uint64        /**< Quantity of pages copied for update */
	Clone   uint64        /**< Quantity of parent's dirty pages clones for nested transactions */
	Split   uint64        /**< Page splits */
	Merge   uint64        /**< Page merges */
	Spill   uint64        /**< Quantity of spilled dirty pages */
	Unspill uint64        /**< Quantity of unspilled/reloaded pages */
	Wops    uint64        /**< Number of explicit write operations (not a pages) to a disk */
	Gcrtime time.Duration /**< Time spent loading and searching inside GC */
}

// EnvInfo contains information an environment.
//
// See MDBX_envinfo.
type EnvInfo struct {
	MapSize int64 // Size of the data memory map
	LastPNO int64 // ID of the last used page
	Geo     EnvInfoGeo
	/** Statistics of page operations.
	 * \details Overall statistics of page operations of all (running, completed
	 * and aborted) transactions in the current multi-process session (since the
	 * first process opened the database). */
	PageOps           EnfInfoPageOps
	LastTxnID         int64         // ID of the last committed transaction
	MaxReaders        uint          // maximum number of threads for the environment
	NumReaders        uint          // maximum number of threads used in the environment
	PageSize          uint          //
	SystemPageSize    uint          //
	AutoSyncThreshold uint          //
	SinceSync         time.Duration //
	AutosyncPeriod    time.Duration //
	SinceReaderCheck  time.Duration //
	Flags             uint          //
}

// Info returns information about the environment.
//
// See mdbx_env_info.
// txn - can be nil
func (env *Env) Info(txn *Txn) (*EnvInfo, error) {
	if txn == nil {
		var err error
		txn, err = env.BeginTxn(nil, Readonly)
		if err != nil {
			return nil, err
		}
		defer txn.Abort()
	}
	var _info  /*line :366:12*/_Ctype_MDBX_envinfo /*line :366:26*/
	ret := func() _Ctype_int{ _cgo0 := /*line :367:28*/env._env; _cgo1 := /*line :367:38*/txn._txn; var _cgo2 *_Ctype_struct_MDBX_envinfo = /*line :367:48*/&_info; var _cgo3 _Ctype_size_t = _Ctype_size_t /*line :367:64*/(unsafe.Sizeof(_info)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :367:87*/_Cfunc_mdbx_env_info_ex(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if ret != success {
		return nil, operrno("mdbx_env_info", ret)
	}
	info := EnvInfo{
		MapSize: int64(_info.mi_mapsize),
		Geo: EnvInfoGeo{
			Lower:   uint64(_info.mi_geo.lower),
			Upper:   uint64(_info.mi_geo.upper),
			Current: uint64(_info.mi_geo.current),
			Shrink:  uint64(_info.mi_geo.shrink),
			Grow:    uint64(_info.mi_geo.grow),
		},
		PageOps: EnfInfoPageOps{
			Newly:   uint64(_info.mi_pgop_stat.newly),
			Cow:     uint64(_info.mi_pgop_stat.cow),
			Clone:   uint64(_info.mi_pgop_stat.clone),
			Split:   uint64(_info.mi_pgop_stat.split),
			Merge:   uint64(_info.mi_pgop_stat.merge),
			Spill:   uint64(_info.mi_pgop_stat.spill),
			Unspill: uint64(_info.mi_pgop_stat.unspill),
			Wops:    uint64(_info.mi_pgop_stat.wops),
			Gcrtime: toDurationU64(_info.mi_pgop_stat.gcrtime_seconds16dot16),
		},
		LastPNO:        int64(_info.mi_last_pgno),
		LastTxnID:      int64(_info.mi_recent_txnid),
		MaxReaders:     uint(_info.mi_maxreaders),
		NumReaders:     uint(_info.mi_numreaders),
		PageSize:       uint(_info.mi_dxb_pagesize),
		SystemPageSize: uint(_info.mi_sys_pagesize),

		AutoSyncThreshold: uint(_info.mi_autosync_threshold),
		SinceSync:         toDuration(_info.mi_since_sync_seconds16dot16),
		AutosyncPeriod:    toDuration(_info.mi_autosync_period_seconds16dot16),
		SinceReaderCheck:  toDuration(_info.mi_since_reader_check_seconds16dot16),
		Flags:             uint(_info.mi_mode),
	}
	return &info, nil
}

// Sync flushes buffers to disk.  If force is true a synchronous flush occurs
// and ignores any UtterlyNoSync or MapAsync flag on the environment.
//
// See mdbx_env_sync.
func (env *Env) Sync(force bool, nonblock bool) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :412:28*/env._env; var _cgo1 _Ctype__Bool = _Ctype_bool /*line :412:44*/(force); var _cgo2 _Ctype__Bool = _Ctype_bool /*line :412:59*/(nonblock); _cgoCheckPointer(_cgo0, nil); return /*line :412:70*/_Cfunc_mdbx_env_sync_ex(_cgo0, _cgo1, _cgo2); }()
	return operrno("mdbx_env_sync_ex", ret)
}

// SetFlags sets flags in the environment.
//
// See mdbx_env_set_flags.
func (env *Env) SetFlags(flags uint) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :420:30*/env._env; var _cgo1 _Ctype_MDBX_env_flags_t = _Ctype_MDBX_env_flags_t /*line :420:58*/(flags); var _cgo2 _Ctype__Bool = /*line :420:67*/true; _cgoCheckPointer(_cgo0, nil); return /*line :420:72*/_Cfunc_mdbx_env_set_flags(_cgo0, _cgo1, _cgo2); }()
	return operrno("mdbx_env_set_flags", ret)
}

// UnsetFlags clears flags in the environment.
//
// See mdbx_env_set_flags.
func (env *Env) UnsetFlags(flags uint) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :428:30*/env._env; var _cgo1 _Ctype_MDBX_env_flags_t = _Ctype_MDBX_env_flags_t /*line :428:58*/(flags); var _cgo2 _Ctype__Bool = /*line :428:67*/false; _cgoCheckPointer(_cgo0, nil); return /*line :428:73*/_Cfunc_mdbx_env_set_flags(_cgo0, _cgo1, _cgo2); }()
	return operrno("mdbx_env_set_flags", ret)
}

// Flags returns the flags set in the environment.
//
// See mdbx_env_get_flags.
func (env *Env) Flags() (uint, error) {
	var _flags  /*line :436:13*/_Ctype_uint /*line :436:19*/
	ret := func() _Ctype_int{ _cgo0 := /*line :437:30*/env._env; var _cgo1 *_Ctype_uint = /*line :437:40*/&_flags; _cgoCheckPointer(_cgo0, nil); return /*line :437:48*/_Cfunc_mdbx_env_get_flags(_cgo0, _cgo1); }()
	if ret != success {
		return 0, operrno("mdbx_env_get_flags", ret)
	}
	return uint(_flags), nil
}

func (env *Env) SetDebug(logLvl LogLvl, dbg int, logger * /*line :444:58*/_Ctype_MDBX_debug_func /*line :444:75*/) error {
	_ = ( /*line :445:6*/_Cfunc_mdbx_setup_debug /*line :445:23*/)(logLvl,  /*line :445:33*/_Ctype_MDBX_debug_flags_t /*line :445:53*/(dbg), logger)
	return nil
}

// Path returns the path argument passed to Open.  Path returns a non-nil error
// if env.Open() was not previously called.
//
// See mdbx_env_get_path.
func (env *Env) Path() (string, error) {
	var cpath * /*line :454:13*/_Ctype_char /*line :454:19*/
	ret := func() _Ctype_int{ _cgo0 := /*line :455:29*/env._env; _cgoBase1 := /*line :455:39*/&cpath; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :455:46*/_Cfunc_mdbx_env_get_path(_cgo0, _cgo1); }()
	if ret != success {
		return "", operrno("mdbx_env_get_path", ret)
	}
	if cpath == nil {
		return "", errNotOpen
	}
	return ( /*line :462:9*/_Cfunc_GoString /*line :462:18*/)(cpath), nil
}

func (env *Env) SetOption(option uint, value uint64) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :466:31*/env._env; var _cgo1 _Ctype_MDBX_option_t = _Ctype_MDBX_option_t /*line :466:56*/(option); var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t /*line :466:76*/(value); _cgoCheckPointer(_cgo0, nil); return /*line :466:84*/_Cfunc_mdbx_env_set_option(_cgo0, _cgo1, _cgo2); }()
	return operrno("mdbx_env_set_option", ret)
}

func (env *Env) GetOption(option uint) (uint64, error) {
	var res  /*line :471:10*/_Ctype_uint64_t /*line :471:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :472:31*/env._env; var _cgo1 _Ctype_MDBX_option_t = _Ctype_MDBX_option_t /*line :472:56*/(option); var _cgo2 *_Ctype_uint64_t = /*line :472:66*/&res; _cgoCheckPointer(_cgo0, nil); return /*line :472:71*/_Cfunc_mdbx_env_get_option(_cgo0, _cgo1, _cgo2); }()
	return uint64(res), operrno("mdbx_env_get_option", ret)
}

func (env *Env) SetSyncPeriod(value time.Duration) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :477:35*/env._env; var _cgo1 _Ctype_uint = _Ctype_uint /*line :477:51*/(NewDuration16dot16(value)); _cgoCheckPointer(_cgo0, nil); return /*line :477:79*/_Cfunc_mdbx_env_set_syncperiod(_cgo0, _cgo1); }()
	return operrno("mdbx_env_set_syncperiod", ret)
}

func (env *Env) GetSyncPeriod() (time.Duration, error) {
	var res  /*line :482:10*/_Ctype_uint /*line :482:16*/
	ret := func() _Ctype_int{ _cgo0 := /*line :483:35*/env._env; var _cgo1 *_Ctype_uint = /*line :483:45*/&res; _cgoCheckPointer(_cgo0, nil); return /*line :483:50*/_Cfunc_mdbx_env_get_syncperiod(_cgo0, _cgo1); }()
	return Duration16dot16(res).ToDuration(), operrno("mdbx_env_get_syncperiod", ret)
}

func (env *Env) SetGeometry(sizeLower int, sizeNow int, sizeUpper int, growthStep int, shrinkThreshold int, pageSize int) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :488:33*/env._env; var _cgo1 _Ctype_intptr_t = _Ctype_intptr_t /*line :489:13*/(sizeLower); var _cgo2 _Ctype_intptr_t = _Ctype_intptr_t /*line :490:13*/(sizeNow); var _cgo3 _Ctype_intptr_t = _Ctype_intptr_t /*line :491:13*/(sizeUpper); var _cgo4 _Ctype_intptr_t = _Ctype_intptr_t /*line :492:13*/(growthStep); var _cgo5 _Ctype_intptr_t = _Ctype_intptr_t /*line :493:13*/(shrinkThreshold); var _cgo6 _Ctype_intptr_t = _Ctype_intptr_t /*line :494:13*/(pageSize); _cgoCheckPointer(_cgo0, nil); return /*line :494:24*/_Cfunc_mdbx_env_set_geometry(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	return operrno("mdbx_env_set_geometry", ret)
}

// MaxKeySize returns the maximum allowed length for a key.
//
// See mdbx_env_get_maxkeysize.
func (env *Env) MaxKeySize() int {
	if env == nil {
		return int(( /*line :503:14*/_Cfunc_mdbx_env_get_maxkeysize_ex /*line :503:41*/)(nil, 0))
	}
	return int(func() _Ctype_int{ _cgo0 := /*line :505:42*/env._env; var _cgo1 _Ctype_MDBX_db_flags_t = /*line :505:52*/0; _cgoCheckPointer(_cgo0, nil); return /*line :505:54*/_Cfunc_mdbx_env_get_maxkeysize_ex(_cgo0, _cgo1); }())
}

// BeginTxn is an unsafe, low-level method to initialize a new transaction on
// env.  The Txn returned by BeginTxn is unmanaged and must be terminated by
// calling either its Abort or Commit methods to ensure that its resources are
// released.
//
// BeginTxn does not call runtime.LockOSThread.  Unless the Readonly flag is
// passed goroutines must call runtime.LockOSThread before calling BeginTxn and
// the returned Txn must not have its methods called from another goroutine.
// Failure to meet these restrictions can have undefined results that may
// include deadlocking your application.
//
// Instead of calling BeginTxn users should prefer calling the View and Update
// methods, which assist in management of Txn objects and provide OS thread
// locking required for write transactions.
//
// Unterminated transactions can adversly effect
// database performance and cause the database to grow until the map is full.
//
// See mdbx_txn_begin.
func (env *Env) BeginTxn(parent *Txn, flags uint) (*Txn, error) {
	return beginTxn(env, parent, flags)
}

// RunTxn creates a new Txn and calls fn with it as an argument.  Run commits
// the transaction if fn returns nil otherwise the transaction is aborted.
// Because RunTxn terminates the transaction goroutines should not retain
// references to it or its data after fn returns.
//
// RunTxn does not call runtime.LockOSThread.  Unless the Readonly flag is
// passed the calling goroutine should ensure it is locked to its thread and
// any goroutines started by fn must not call methods on the Txn object it is
// passed.
//
// See mdbx_txn_begin.
func (env *Env) RunTxn(flags uint, fn TxnOp) error {
	return env.run(false, flags, fn)
}

// View creates a readonly transaction with a consistent view of the
// environment and passes it to fn.  View terminates its transaction after fn
// returns.  Any error encountered by View is returned.
//
// Unlike with Update transactions, goroutines created by fn are free to call
// methods on the Txn passed to fn provided they are synchronized in their
// accesses (e.g. using a mutex or channel).
//
// Any call to Commit, Abort, Reset or Renew on a Txn created by View will
// panic.
func (env *Env) View(fn TxnOp) error {
	return env.run(false, Readonly, fn)
}

// Update calls fn with a writable transaction.  Update commits the transaction
// if fn returns a nil error otherwise Update aborts the transaction and
// returns the error.
//
// Update calls runtime.LockOSThread to lock the calling goroutine to its
// thread and until fn returns and the transaction has been terminated, at
// which point runtime.UnlockOSThread is called.  If the calling goroutine is
// already known to be locked to a thread, use UpdateLocked instead to avoid
// premature unlocking of the goroutine.
//
// Neither Update nor UpdateLocked cannot be called safely from a goroutine
// where it isn't known if runtime.LockOSThread has been called.  In such
// situations writes must either be done in a newly created goroutine which can
// be safely locked, or through a worker goroutine that accepts updates to
// apply and delivers transaction results using channels.  See the package
// documentation and examples for more details.
//
// Goroutines created by the operation fn must not use methods on the Txn
// object that fn is passed.  Doing so would have undefined and unpredictable
// results for your program (likely including data loss, deadlock, etc).
//
// Any call to Commit, Abort, Reset or Renew on a Txn created by Update will
// panic.
func (env *Env) Update(fn TxnOp) error {
	return env.run(true, 0, fn)
}

// UpdateLocked behaves like Update but does not lock the calling goroutine to
// its thread.  UpdateLocked should be used if the calling goroutine is already
// locked to its thread for another purpose.
//
// Neither Update nor UpdateLocked cannot be called safely from a goroutine
// where it isn't known if runtime.LockOSThread has been called.  In such
// situations writes must either be done in a newly created goroutine which can
// be safely locked, or through a worker goroutine that accepts updates to
// apply and delivers transaction results using channels.  See the package
// documentation and examples for more details.
//
// Goroutines created by the operation fn must not use methods on the Txn
// object that fn is passed.  Doing so would have undefined and unpredictable
// results for your program (likely including data loss, deadlock, etc).
//
// Any call to Commit, Abort, Reset or Renew on a Txn created by UpdateLocked
// will panic.
func (env *Env) UpdateLocked(fn TxnOp) error {
	return env.run(false, 0, fn)
}

func (env *Env) run(lock bool, flags uint, fn TxnOp) error {
	if lock {
		runtime.LockOSThread()
		defer runtime.UnlockOSThread()
	}
	txn, err := beginTxn(env, nil, flags)
	if err != nil {
		return err
	}
	return txn.runOpTerm(fn)
}

// CloseDBI closes the database handle, db.  Normally calling CloseDBI
// explicitly is not necessary.
//
// It is the caller's responsibility to serialize calls to CloseDBI.
//
// See mdbx_dbi_close.
func (env *Env) CloseDBI(db DBI) {
	func() _Ctype_int{ _cgo0 := /*line :627:19*/env._env; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :627:39*/(db); _cgoCheckPointer(_cgo0, nil); return /*line :627:44*/_Cfunc_mdbx_dbi_close(_cgo0, _cgo1); }()
}
