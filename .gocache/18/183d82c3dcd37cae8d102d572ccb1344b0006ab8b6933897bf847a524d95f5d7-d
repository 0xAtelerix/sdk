// Code generated by cmd/cgo; DO NOT EDIT.

//line /Users/ai/go/pkg/mod/github.com/erigontech/mdbx-go@v0.27.14/mdbx/cursor.go:1:1
package mdbx

/*
#include <stdlib.h>
#include <stdio.h>
#include "mdbxgo.h"
*/
import _ "unsafe"
import (
	"fmt"
	"sync"
	"unsafe"
)

const (
	// Flags for Cursor.Get
	//
	// See MDB_cursor_op.

	First        = ( /*line :20:17*/_Ciconst_MDBX_FIRST /*line :20:28*/)          // The first item.
	FirstDup     = ( /*line :21:17*/_Ciconst_MDBX_FIRST_DUP /*line :21:32*/)      // The first value of current key (DupSort).
	GetBoth      = ( /*line :22:17*/_Ciconst_MDBX_GET_BOTH /*line :22:31*/)       // Get the key as well as the value (DupSort).
	GetBothRange = ( /*line :23:17*/_Ciconst_MDBX_GET_BOTH_RANGE /*line :23:37*/) // Get the key and the nearsest value (DupSort).
	GetCurrent   = ( /*line :24:17*/_Ciconst_MDBX_GET_CURRENT /*line :24:34*/)    // Get the key and value at the current position.
	GetMultiple  = ( /*line :25:17*/_Ciconst_MDBX_GET_MULTIPLE /*line :25:35*/)   // Get up to a page dup values for key at current position (DupFixed).
	Last         = ( /*line :26:17*/_Ciconst_MDBX_LAST /*line :26:27*/)           // Last item.
	LastDup      = ( /*line :27:17*/_Ciconst_MDBX_LAST_DUP /*line :27:31*/)       // Position at last value of current key (DupSort).
	Next         = ( /*line :28:17*/_Ciconst_MDBX_NEXT /*line :28:27*/)           // Next value.
	NextDup      = ( /*line :29:17*/_Ciconst_MDBX_NEXT_DUP /*line :29:31*/)       // Next value of the current key (DupSort).
	NextMultiple = ( /*line :30:17*/_Ciconst_MDBX_NEXT_MULTIPLE /*line :30:36*/)  // Get key and up to a page of values from the next cursor position (DupFixed).
	NextNoDup    = ( /*line :31:17*/_Ciconst_MDBX_NEXT_NODUP /*line :31:33*/)     // The first value of the next key (DupSort).
	Prev         = ( /*line :32:17*/_Ciconst_MDBX_PREV /*line :32:27*/)           // The previous item.
	PrevDup      = ( /*line :33:17*/_Ciconst_MDBX_PREV_DUP /*line :33:31*/)       // The previous item of the current key (DupSort).
	PrevNoDup    = ( /*line :34:17*/_Ciconst_MDBX_PREV_NODUP /*line :34:33*/)     // The last data item of the previous key (DupSort).
	PrevMultiple = ( /*line :35:17*/_Ciconst_MDBX_PREV_MULTIPLE /*line :35:36*/)  //
	Set          = ( /*line :36:17*/_Ciconst_MDBX_SET /*line :36:26*/)            // The specified key.
	SetKey       = ( /*line :37:17*/_Ciconst_MDBX_SET_KEY /*line :37:30*/)        // Get key and data at the specified key.
	SetRange     = ( /*line :38:17*/_Ciconst_MDBX_SET_RANGE /*line :38:32*/)      // The first key no less than the specified key.
)

// The MDB_MULTIPLE and MDB_RESERVE flags are special and do not fit the
// calling pattern of other calls to Put.  They are not exported because they
// require special methods, PutMultiple and PutReserve in which the flag is
// implied and does not need to be passed.
const (
	// Flags for Txn.Put and Cursor.Put.
	//
	// See mdb_put and mdb_cursor_put.
	Upsert      = ( /*line :49:16*/_Ciconst_MDBX_UPSERT /*line :49:28*/)      // Replace the item at the current key position (Cursor only)
	Current     = ( /*line :50:16*/_Ciconst_MDBX_CURRENT /*line :50:29*/)     // Replace the item at the current key position (Cursor only)
	NoDupData   = ( /*line :51:16*/_Ciconst_MDBX_NODUPDATA /*line :51:31*/)   // Store the key-value pair only if key is not present (DupSort).
	NoOverwrite = ( /*line :52:16*/_Ciconst_MDBX_NOOVERWRITE /*line :52:33*/) // Store a new key-value pair only if key is not present.
	Append      = ( /*line :53:16*/_Ciconst_MDBX_APPEND /*line :53:28*/)      // Append an item to the database.
	AppendDup   = ( /*line :54:16*/_Ciconst_MDBX_APPENDDUP /*line :54:31*/)   // Append an item to the database (DupSort).
	AllDups     = ( /*line :55:16*/_Ciconst_MDBX_ALLDUPS /*line :55:29*/)
)

// Cursor operates on data inside a transaction and holds a position in the
// database.
//
// See MDB_cursor.
type Cursor struct {
	txn *Txn
	_c  * /*line :64:7*/_Ctype_MDBX_cursor /*line :64:20*/
}

func openCursor(txn *Txn, db DBI) (*Cursor, error) {
	c := &Cursor{txn: txn}
	ret := func() _Ctype_int{ _cgo0 := /*line :69:28*/txn._txn; var _cgo1 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :69:48*/(db); _cgoBase2 := /*line :69:54*/&c._c; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :69:60*/_Cfunc_mdbx_cursor_open(_cgo0, _cgo1, _cgo2); }()
	if ret != success {
		return nil, operrno("mdbx_cursor_open", ret)
	}
	return c, nil
}

// Renew associates cursor with txn.
//
// See mdb_cursor_renew.
func (c *Cursor) Renew(txn *Txn) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :80:29*/txn._txn; _cgo1 := /*line :80:39*/c._c; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :80:44*/_Cfunc_mdbx_cursor_renew(_cgo0, _cgo1); }()
	if ret != success {
		return operrno("mdbx_cursor_renew", ret)
	}
	c.txn = txn
	return nil
}

// Bind Using of the `mdbx_cursor_bind()` is equivalent to calling mdbx_cursor_renew() but with specifying an arbitrary
// dbi handle.
func (c *Cursor) Bind(txn *Txn, db DBI) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :91:28*/txn._txn; _cgo1 := /*line :91:38*/c._c; var _cgo2 _Ctype_MDBX_dbi = _Ctype_MDBX_dbi /*line :91:54*/(db); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :91:59*/_Cfunc_mdbx_cursor_bind(_cgo0, _cgo1, _cgo2); }()
	if ret != success {
		return operrno("mdbx_cursor_bind", ret)
	}
	c.txn = txn
	return nil
}

// Close the cursor handle and clear the finalizer on c.  Cursors belonging to
// write transactions are closed automatically when the transaction is
// terminated.
//
// See mdb_cursor_close.
func (c *Cursor) Close() {
	if c._c != nil {
		if c.txn._txn == nil && !c.txn.readonly {
			// the cursor has already been released by MDBX.
		} else {
			func() { _cgo0 := /*line :109:24*/c._c; _cgoCheckPointer(_cgo0, nil); /*line :109:29*/_Cfunc_mdbx_cursor_close(_cgo0); }()
		}
		c.txn = nil
		c._c = nil
	}
}

// Txn returns the cursor's transaction.
func (c *Cursor) Txn() *Txn {
	return c.txn
}

// DBI returns the cursor's database handle.  If c has been closed than an
// invalid DBI is returned.
func (c *Cursor) DBI() DBI {
	// dbiInvalid is an invalid DBI (the max value for the type).  it shouldn't
	// be possible to create a database handle with value dbiInvalid because
	// the process address space would be exhausted.  it is also impractical to
	// have many open databases in an environment.
	const dbiInvalid = ^DBI(0)

	// mdb_cursor_dbi segfaults when passed a nil value
	if c._c == nil {
		return dbiInvalid
	}
	return DBI(func() _Ctype_MDBX_dbi{ _cgo0 := /*line :134:31*/c._c; _cgoCheckPointer(_cgo0, nil); return /*line :134:36*/_Cfunc_mdbx_cursor_dbi(_cgo0); }())
}

// Get retrieves items from the database. If c.Txn().RawRead is true the slices
// returned by Get reference readonly sections of memory that must not be
// accessed after the transaction has terminated.
//
// In a Txn with RawRead set to true the Set op causes the returned key to
// share its memory with setkey (making it writable memory). In a Txn with
// RawRead set to false the Set op returns key values with memory distinct from
// setkey, as is always the case when using RawRead.
//
// Get ignores setval if setkey is empty.
//
// See mdb_cursor_get.
func (c *Cursor) Get(setkey, setval []byte, op uint) (key, val []byte, err error) {
	switch {
	case len(setkey) == 0:
		err = c.getVal0(op)
	case len(setval) == 0:
		err = c.getVal1(setkey, op)
	default:
		err = c.getVal2(setkey, setval, op)
	}
	if err != nil {
		*c.txn.key =  /*line :159:16*/_Ctype_MDBX_val /*line :159:26*/{}
		*c.txn.val =  /*line :160:16*/_Ctype_MDBX_val /*line :160:26*/{}
		return nil, nil, err
	}

	// When MDB_SET is passed to mdb_cursor_get its first argument will be
	// returned unchanged.  Unfortunately, the normal slice copy/extraction
	// routines will be bad for the Go runtime when operating on Go memory
	// (panic or potentially garbage memory reference).
	if op == Set {
		key = setkey
	} else {
		if op != LastDup && op != FirstDup {
			key = castToBytes(c.txn.key)
		}
	}
	val = castToBytes(c.txn.val)

	// Clear transaction storage record storage area for future use and to
	// prevent dangling references.
	*c.txn.key =  /*line :179:15*/_Ctype_MDBX_val /*line :179:25*/{}
	*c.txn.val =  /*line :180:15*/_Ctype_MDBX_val /*line :180:25*/{}

	return key, val, nil
}

// getVal0 retrieves items from the database without using given key or value
// data for reference (Next, First, Last, etc).
//
// See mdb_cursor_get.
func (c *Cursor) getVal0(op uint) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :190:27*/c._c; _cgo1 := /*line :190:33*/c.txn.key; _cgo2 := /*line :190:44*/c.txn.val; var _cgo3 _Ctype_MDBX_cursor_op = _Ctype_MDBX_cursor_op /*line :190:71*/(op); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return /*line :190:76*/_Cfunc_mdbx_cursor_get(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return operrno("mdbx_cursor_get", ret)
}

// getVal1 retrieves items from the database using key data for reference
// (Set, SetRange, etc).
//
// See mdb_cursor_get.
func (c *Cursor) getVal1(setkey []byte, op uint) error {
	var k * /*line :199:9*/_Ctype_char /*line :199:15*/
	if len(setkey) > 0 {
		k = (* /*line :201:9*/_Ctype_char /*line :201:15*/)(unsafe.Pointer(&setkey[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :204:3*/c._c; var _cgo1 *_Ctype_char = /*line :205:3*/k; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :205:14*/(len(setkey)); _cgo3 := /*line :206:3*/c.txn.key; _cgo4 := /*line :207:3*/c.txn.val; var _cgo5 _Ctype_MDBX_cursor_op = _Ctype_MDBX_cursor_op /*line :208:19*/(op); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo4, nil); return /*line :209:3*/_Cfunc_mdbxgo_cursor_get1(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return operrno("mdbx_cursor_get", ret)
}

// getVal2 retrieves items from the database using key and value data for
// reference (GetBoth, GetBothRange, etc).
//
// See mdb_cursor_get.
func (c *Cursor) getVal2(setkey, setval []byte, op uint) error {
	var k, v * /*line :218:12*/_Ctype_char /*line :218:18*/
	if len(setkey) > 0 {
		k = (* /*line :220:9*/_Ctype_char /*line :220:15*/)(unsafe.Pointer(&setkey[0]))
	}
	if len(setval) > 0 {
		v = (* /*line :223:9*/_Ctype_char /*line :223:15*/)(unsafe.Pointer(&setval[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :226:3*/c._c; var _cgo1 *_Ctype_char = /*line :227:3*/k; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :227:14*/(len(setkey)); var _cgo3 *_Ctype_char = /*line :228:3*/v; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :228:14*/(len(setval)); _cgo5 := /*line :229:3*/c.txn.key; _cgo6 := /*line :229:14*/c.txn.val; var _cgo7 _Ctype_MDBX_cursor_op = _Ctype_MDBX_cursor_op /*line :230:19*/(op); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo5, nil); _cgoCheckPointer(_cgo6, nil); return /*line :231:3*/_Cfunc_mdbxgo_cursor_get2(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()
	return operrno("mdbx_cursor_get", ret)
}

// Put stores an item in the database.
//
// See mdb_cursor_put.
func (c *Cursor) Put(key, val []byte, flags uint) error {
	var k, v * /*line :239:12*/_Ctype_char /*line :239:18*/
	if len(key) > 0 {
		k = (* /*line :241:9*/_Ctype_char /*line :241:15*/)(unsafe.Pointer(&key[0]))
	}
	if len(val) > 0 {
		v = (* /*line :244:9*/_Ctype_char /*line :244:15*/)(unsafe.Pointer(&val[0]))
	}
	ret := func() _Ctype_int{ _cgo0 := /*line :247:3*/c._c; var _cgo1 *_Ctype_char = /*line :248:3*/k; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :248:14*/(len(key)); var _cgo3 *_Ctype_char = /*line :249:3*/v; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :249:14*/(len(val)); var _cgo5 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :250:21*/(flags); _cgoCheckPointer(_cgo0, nil); return /*line :251:3*/_Cfunc_mdbxgo_cursor_put2(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return operrno("mdbx_cursor_put", ret)
}

// PutReserve returns a []byte of length n that can be written to, potentially
// avoiding a memcopy.  The returned byte slice is only valid in txn's thread,
// before it has terminated.
func (c *Cursor) PutReserve(key []byte, n int, flags uint) ([]byte, error) {
	var k * /*line :259:9*/_Ctype_char /*line :259:15*/
	if len(key) > 0 {
		k = (* /*line :261:9*/_Ctype_char /*line :261:15*/)(unsafe.Pointer(&key[0]))
	}
	c.txn.val.iov_len =  /*line :263:22*/_Ctype_size_t /*line :263:30*/(n)
	ret := func() _Ctype_int{ _cgo0 := /*line :265:3*/c._c; var _cgo1 *_Ctype_char = /*line :266:3*/k; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :266:14*/(len(key)); _cgo3 := /*line :267:3*/c.txn.val; var _cgo4 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :268:21*/(flags | _Ciconst_MDBX_RESERVE /*line :268:42*/); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return /*line :269:3*/_Cfunc_mdbxgo_cursor_put1(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	err := operrno("mdbx_cursor_put", ret)
	if err != nil {
		*c.txn.val =  /*line :272:16*/_Ctype_MDBX_val /*line :272:26*/{}
		return nil, err
	}
	b := castToBytes(c.txn.val)
	*c.txn.val =  /*line :276:15*/_Ctype_MDBX_val /*line :276:25*/{}
	return b, nil
}

// PutMulti stores a set of contiguous items with stride size under key.
// PutMulti panics if len(page) is not a multiple of stride.  The cursor's
// database must be DupFixed and DupSort.
//
// See mdb_cursor_put.
func (c *Cursor) PutMulti(key []byte, page []byte, stride int, flags uint) error {
	var k * /*line :286:9*/_Ctype_char /*line :286:15*/
	if len(key) > 0 {
		k = (* /*line :288:9*/_Ctype_char /*line :288:15*/)(unsafe.Pointer(&key[0]))
	}
	var v * /*line :290:9*/_Ctype_char /*line :290:15*/
	if len(page) > 0 {
		v = (* /*line :292:9*/_Ctype_char /*line :292:15*/)(unsafe.Pointer(&page[0]))
	}
	vn := WrapMulti(page, stride).Len()
	ret := func() _Ctype_int{ _cgo0 := /*line :296:3*/c._c; var _cgo1 *_Ctype_char = /*line :297:3*/k; var _cgo2 _Ctype_size_t = _Ctype_size_t /*line :297:14*/(len(key)); var _cgo3 *_Ctype_char = /*line :298:3*/v; var _cgo4 _Ctype_size_t = _Ctype_size_t /*line :298:14*/(vn); var _cgo5 _Ctype_size_t = _Ctype_size_t /*line :298:28*/(stride); var _cgo6 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :299:21*/(flags | _Ciconst_MDBX_MULTIPLE /*line :299:43*/); _cgoCheckPointer(_cgo0, nil); return /*line :300:3*/_Cfunc_mdbxgo_cursor_putmulti(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	return operrno("mdbxgo_cursor_putmulti", ret)
}

// Del deletes the item referred to by the cursor from the database.
//
// See mdb_cursor_del.
func (c *Cursor) Del(flags uint) error {
	ret := func() _Ctype_int{ _cgo0 := /*line :308:27*/c._c; var _cgo1 _Ctype_MDBX_put_flags_t = _Ctype_MDBX_put_flags_t /*line :308:51*/(flags); _cgoCheckPointer(_cgo0, nil); return /*line :308:59*/_Cfunc_mdbx_cursor_del(_cgo0, _cgo1); }()
	return operrno("mdbx_cursor_del", ret)
}

// Count returns the number of duplicates for the current key.
//
// See mdb_cursor_count.
func (c *Cursor) Count() (uint64, error) {
	var _size  /*line :316:12*/_Ctype_size_t /*line :316:20*/
	ret := func() _Ctype_int{ _cgo0 := /*line :317:29*/c._c; var _cgo1 *_Ctype_size_t = /*line :317:35*/&_size; _cgoCheckPointer(_cgo0, nil); return /*line :317:42*/_Cfunc_mdbx_cursor_count(_cgo0, _cgo1); }()
	if ret != success {
		return 0, operrno("mdbx_cursor_count", ret)
	}
	return uint64(_size), nil
}

var cursorPool = sync.Pool{
	New: func() interface{} {
		return CreateCursor()
	},
}

func CursorFromPool() *Cursor { return cursorPool.Get().(*Cursor) }
func CursorToPool(c *Cursor)  { cursorPool.Put(c) }

func CreateCursor() *Cursor {
	c := &Cursor{_c: ( /*line :334:19*/_Cfunc_mdbx_cursor_create /*line :334:38*/)(nil)}
	if c._c == nil {
		panic(fmt.Errorf("mdbx.CreateCursor: OOM"))
	}
	return c
}
